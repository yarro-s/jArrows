# Стрелки как новый подход к программированию на Java 8

Во многих областях используется описание систем и процессов в виде блок-схем. Особенностью блок-схемы 
является наглядное представление последовательностей операций без акцентирования внимания на самих обрабатываемых данных (переменных) и их состояниях. Для примера рассмотрим радиоприёмник прямого усиления

// блок-схема приёмника

Традиционное описанние такой схемы на Си-подобном языке программирования выглядело бы примерно так 

```Java
Antenna antenna = new Antenna(Ether.getInstance());
Filter filter1 = new Filter(5000);       // параметр - частота настройки
Filter filter2 = new Filter(5000);
Filter filter3 = new Filter(5000);

Detector detector = new Detector("AM"); // тип модуляции - амплитудная
Amplifier amp = new Amplifier(5);       // коэффициент усиления
Speaker speaker = new Speaker(10);      // громкость

Signal inputSignal = antenna.receive();

Signal filter1Res = filter1.filter(inputSignal);
Signal filter2Res = filter2.filter(filter1Res);
Signal filter3Res = filter3.filter(filter2Res);
Signal detected = detector.detect(filter3Res);
Signal amplified = amp.amplify(detected);

speaker.speak(amplified);
```

Видно, что в программу добавились переменные, которых не было в блок-схеме, и которые, 
следовательно, не добавляют никакой информации о работе радиоприёмника и нужны лишь для 
хранения промежуточных результатов обработки.

Такая программа, которая описывает лишь простое поэтапное прохождение сигнала через блоки 
обработки, без параллельных блоков и обратных связей, выглядит достаточно сложночитаемо, даже 
если опустить этап создания экземпляров самих блоков. Хотя применение шаблона Builder может 
упростить описание, оно добавит сложность в описание классов блоков, и мало поможет при наличии 
параллельных блоков.

Более удобным вариантом этой программы будет непосредственное описание схемы с использование дополнительных 
методов, описывающих соединения блоков без дополнительных переменных:

```Java

Receiver receiver = Receiver.join(filter1).join(filter2).join(filter3)
    .join(detector).join(amp).join(speaker);
    
receiver.apply(antenna.receive());
```

Метод `join()` описывает последовательное соединение блоков, то есть `a.join(b)` означает, что результат 
обработки блоком `a` будет передан на вход блока `b`.

При этом лишь требуется, чтобы соединяемые классы `Filter`, `Amplifier`, `Detector`, `Speaker` реализовывали некоторый метод `apply()`, выполняющий "действие по-умолчанию" (для фильтра `Filter` - `filter()`, для `Amplifier` - `amplify()` и т. д.) и позволяющий вызывать объект как функцию.

При функциональном подходе эти классы были бы функциями, возвращающими функции, так что нам не пришлось бы даже создавать экземпляры классов и вся программа выглядела б так:

```Java
Receiver receiver = Receiver.join(filter(1)).join(filter(2)).join(filter(3))
    .join(detector("AM")).join(amplifier(5)).join(speaker(10));
    
receiver.apply(antenna.receive());
```

Параллельное соединение блоков также легко реализовать методом `split()`: `a.split(b,c)` будет описывать
схему, в которой выход блока `a` будет передаваться на входы блоков `b` и `c`.

Как же реализовать такой способ описания систем и вычислений в рамках существующих мейнстримовых 
языков программирования?

## Стрелки как способ описания вычислений
Одной из особенностей функционального подхода является использование комбинаторов, которые являются 
функциями, объединяющими другие функции в составные вычисления. Примером комбинатора являются монады. 
Стрелки (*arrows*), [описанные](http://www.cse.chalmers.se/~rjmh/Papers/arrows.pdf) Джоном Хьюзом, 
являются комбинатором и позволяют обобщенно описывать составные вычисления. 

Стрелки используются в Haskell, например в FRP-фреймворках [Yampa](https://wiki.haskell.org/Yampa) и 
[Netwire](http://hackage.haskell.org/package/netwire), а также в XML-фреймворке
 [Haskell XML Toolbox](http://www.fh-wedel.de/~si/HXmlToolbox/index.html).

### Что такое стрелка
Стрелка `Arrow<In, Out> a` от функции `Out f(In x)` представляет вычисление, которое выполняется функцией 
`f`. 
Как вы уже могли догадаться `In` - тип принимаемого функцией значения, `Out` - тип возвращаемого значения. 
Преимуществом представления вычислений в виде стрелок является возможность явного комбинирования вычислений 
различными способами.

Например функцию `double multBy5_0(int in) { return in*5.0; }` можно представить в виде стрелки 
`Arrow<Integer, Double> arrMultBy5_0 = Action.of(multBy5_0);`.

Класс `Action` реализует интерфейс `Arrow`, другой реализацией этого интерфейса является `ParallelAction`, поддерживающий многопоточные вычисления. Здесь и далее используется реализация стрелок на Java 8 [jArrows](https://github.com/yarric/jArrows).

### Композиция стрелок
Стрелку `arrMultBy5_0` можно последовательно подсоединить к другой стрелке, к примеру прибавляющей к входному
значению 10.5, а затем - к следующей стрелке, представляющей результат в виде строки. Получится цепочка 
из стрелок

```
Arrow<Integer, String> mult5Plus10toStr = arrMultBy5_0.join(in -> in+10.5)
                                                      .join(in -> String.valueOf(in));
mult5Plus10toStr.apply(10);      //  "60.5"                  
```  

При этом лямбда-функции автоматически преобразуются в стрелки. Получившееся вычисление, представленное составной стрелкой `mult5Plus10toStr`, можно представить в виде блок-схемы:

Вход получившейся составной стрелки имеет тип `Integer`, то есть входной тип первого вычисления в цепочке, 
а выход имеет тип `String` - выходной тип последнего вычисления в цепочке. 
Таким образом метод `someArrow.join(f)` соединяет в цепочку высление, представленное стрелкой `someArrow` с вычислением, представленным `f`, при этом `f` может быть другой стрелкой, лямбда-функцией, методом, или чем-то ещё, что реализует `Applicable`, то есть имеет метод `apply(x)`, который можно применить к входному значению `x`.

<Спойлер>Несколько упрощенная реализация `join()`

```Java
class Action<In, Out> implements Arrow<In, Out>, Applicable<In, Out> {
	Applicable<In, Out> func;

    public Arrow<In, OutB> join(Applicable<Out, OutB> b) {
		return Arrow.of(i -> b.apply(this.func.apply(i)));
	}
}
```
где `In` - тип входных данных стрелки `a`, `OutB` - тип выходных данных `b`, 
и он же - тип выходных данных получившейся новой составной стрелки `a_b = a.join(b)`, 
`Out` - тип выходных данных стрелки `a`, он же - тип входных данных стрелки `b`. Функция `func` 
хранится в экземпляре стрелки, инициализируется при её создании и выполняет само вычисление. 
Аргумент `b` поддерживает интерфейс `Applicable` и может быть другой стрелкой или функцией, 
поэтому мы просто применяем `b` к результату применения `a.func(i)` к входным данным `i` 
стрелки `a_b`. Сам входные данные будут переданы при вызове `apply`, так что `a_b.apply(x)` вернёт 
результат вычисления `b.func(a.func(x))`.

</Спойлер>

### Другие способы композиции стрелок
Кроме последовательного соединения методом `join` стрелки можно соединять параллельно методами `combine`, 
`cloneInput` и `split`. Пример использования метода `combine` для описания вычисления `sin(x)^2+cos(x)^2`

```
Arrow<Pair<Double, Double>, Pair<Double, Double>> 
	sin_cos = Arrow.of(Math::sin).combine(Math::cos);

Arrow<Double, Double> sqr = Arrow.of(i -> i*i);

Arrow<Pair<Double, Double>, Double> sum_SinCos = sin_cos.join(sqr.combine(sqr))
												 .join(p -> p.left + p.right);

sum_SinCos.apply(Pair.of(2.452, 1.546));    // 1.0

```

Получившаяся "широкая" стрелка `sin_cos` принимает на вход пару значений типа `Pair<Double, Double>`, первое значение 
`pair.left` пары попадает на вход первой стрелки, второе `pair.right` - на вход второй, их результаты тоже объединяются в пару. Следующая составная стрелка `sqr` принимает на вход значение типа `Pair<Double, Double>`и возводит оба значения пары в квадрат. Последняя стрелка суммирует пару выходных значений стрелки 
sqr.combine(sqr).

`someArrow.cloneInput(f)` создаёт стрелку, параллельно соединяя `someArrow` и `f` и применяя их к входу, 
её выход представляется в виде пары, объединяющей результаты вычилений этих стрелок. Входные типы 
`someArrow` и `f` должны совпадать.

```Java
Arrow<Integer, Pair<Integer, Double>> sqrAndSqrt = Arrow.of(i -> i*i)
														.cloneInput(Math::sqrt); 
sqrAndSqrt.apply(5);  // Pair(25, 2.236)
```

Параллельное соединение в данном случае означает, что результат двух вычислений, соединённых параллельно, 
не зависят друг от друга, в отличии от последовательного соединения методом `join`, когда результат одного вычисления передаётся на вход другого. Многопоточные параллельные соединения реализуется классом 
`ParallelAction`.

`someArrow.split(f, g)` - дополнительный метод, эквивалентный `someArrow.join(f.cloneInput(g))`. Результат вычисления `someArrow` параллельно передаётся на вход `f` и `g`, выходом такой стрелки будет пара с результатами вычислений `f` и `g`. 

### Обход вычислений
В некоторых случаях есть необходимость передачи входного значения стрелки далее по цепочке стрелок вместе 
с результатом вычисления этой стрелки. Это реализуется методом `someArrow.first()` и дополняющим его `someArrow.second()`, преобразующим стрелку `someArrow` так, что получившаяся стрелка передаёт на выход пару, содержащую результат вычисления `someArrow` и 
само входное значение `someArrow`.

```Java
Arrow<Integer, Double> arr = Arrow.of(i -> Math.sqrt(i*i*i));

arr.first().apply(10);     // Pair(31.623, 10)
arr.second().apply(10);    // Pair(10, 31.623)
```

Эти методы аналогичны методам `someArrow.bypass2nd()` и `someArrow.bypass1st()` соответственно. 

## Немного теории

